import { z } from 'zod';

/**
 * Stance classification for opinions
 */
export const StanceSchema = z.enum([
  'support',
  'oppose',
  'mixed',
  'unclear'
]);

export type Stance = z.infer<typeof StanceSchema>;

/**
 * Aspect tags for categorizing opinions
 */
export const AspectTagSchema = z.enum([
  'cost',
  'safety',
  'ethics',
  'legality',
  'effectiveness',
  'environmental',
  'social_impact',
  'technical',
  'political',
  'economic',
  'health',
  'privacy',
  'security',
  'innovation',
  'tradition',
  'other'
]);

export type AspectTag = z.infer<typeof AspectTagSchema>;

/**
 * Evidence item with source attribution
 */
export const EvidenceSchema = z.object({
  url: z.string().url(),
  title: z.string().nullable(),
  source_name: z.string(),
  source_type: z.string(),
  published_at: z.string().datetime().nullable(),
  excerpt: z.string().max(500), // Short excerpt from the original
});

export type Evidence = z.infer<typeof EvidenceSchema>;

/**
 * Confidence score with reasons
 */
export const ConfidenceScoreSchema = z.object({
  score_0_1: z.number().min(0).max(1),
  reasons: z.array(z.string()),
});

export type ConfidenceScore = z.infer<typeof ConfidenceScoreSchema>;

/**
 * Source breakdown entry
 */
export const SourceBreakdownSchema = z.object({
  source_type: z.string(),
  count: z.number().int().min(0),
  percent: z.number().min(0).max(100),
});

export type SourceBreakdown = z.infer<typeof SourceBreakdownSchema>;

/**
 * Stance distribution entry
 */
export const StanceDistributionEntrySchema = z.object({
  stance: StanceSchema,
  count: z.number().int().min(0),
  percent: z.number().min(0).max(100),
});

export type StanceDistributionEntry = z.infer<typeof StanceDistributionEntrySchema>;

/**
 * Opinion cluster with evidence
 */
export const ClusterSchema = z.object({
  // Unique cluster identifier
  id: z.string(),

  // Human-readable label (generated by LLM)
  label: z.string(),

  // Overall stance of this cluster
  stance: StanceSchema,

  // Aspect tags for this cluster
  aspect_tags: z.array(AspectTagSchema),

  // Share of total items
  share: z.object({
    count: z.number().int().min(0),
    percent: z.number().min(0).max(100),
  }),

  // Breakdown by source type and language
  breakdown: z.object({
    by_source_type: z.array(z.object({
      source_type: z.string(),
      count: z.number().int().min(0),
    })),
    by_language: z.array(z.object({
      language: z.string(),
      count: z.number().int().min(0),
    })),
  }),

  // Representative evidence items
  evidence: z.array(EvidenceSchema).min(1).max(10),

  // Explanatory notes (generated by LLM)
  notes: z.string(),

  // Cluster confidence
  confidence: ConfidenceScoreSchema,
});

export type Cluster = z.infer<typeof ClusterSchema>;

/**
 * Claim with support/refute evidence (optional feature)
 */
export const ClaimSchema = z.object({
  claim: z.string(),
  support_count: z.number().int().min(0),
  refute_count: z.number().int().min(0),
  mixed_count: z.number().int().min(0),
  evidence_support: z.array(EvidenceSchema).max(5),
  evidence_refute: z.array(EvidenceSchema).max(5),
});

export type Claim = z.infer<typeof ClaimSchema>;

/**
 * Sampling metadata
 */
export const SamplingMetadataSchema = z.object({
  sources_used: z.array(z.string()),
  n_raw: z.number().int().min(0),
  n_after_dedupe: z.number().int().min(0),
  n_analyzed: z.number().int().min(0),
  source_breakdown: z.array(SourceBreakdownSchema),
  domain_caps_applied: z.boolean(),
  weighting_policy: z.object({
    description: z.string(),
    params: z.record(z.string(), z.unknown()),
  }),
});

export type SamplingMetadata = z.infer<typeof SamplingMetadataSchema>;

/**
 * Query parameters echoed back
 */
export const QueryEchoSchema = z.object({
  topic: z.string(),
  timeframe: z.object({
    start: z.string().datetime(),
    end: z.string().datetime(),
  }).nullable(),
  geo_scope: z.string().nullable(),
  language_scope: z.array(z.string()).nullable(),
  user_filters: z.record(z.string(), z.unknown()),
});

export type QueryEcho = z.infer<typeof QueryEchoSchema>;

/**
 * Overall confidence and warnings
 */
export const OverallConfidenceSchema = z.object({
  overall_score_0_1: z.number().min(0).max(1),
  limitations: z.array(z.string()),
  warnings: z.array(z.string()),
});

export type OverallConfidence = z.infer<typeof OverallConfidenceSchema>;

/**
 * Complete analysis output schema
 * This is the full JSON contract for the API response
 */
export const AnalysisOutputSchema = z.object({
  // Analysis metadata
  analysis_id: z.string().uuid(),
  created_at: z.string().datetime(),
  completed_at: z.string().datetime().nullable(),
  status: z.enum(['pending', 'processing', 'completed', 'failed']),

  // Query echo
  query: QueryEchoSchema,

  // Sampling statistics
  sampling: SamplingMetadataSchema,

  // Overall stance distribution
  stance_distribution: z.array(StanceDistributionEntrySchema),

  // Opinion clusters
  clusters: z.array(ClusterSchema),

  // Optional: extracted claims
  claims: z.array(ClaimSchema).optional(),

  // Overall confidence and limitations
  confidence: OverallConfidenceSchema,
});

export type AnalysisOutput = z.infer<typeof AnalysisOutputSchema>;

/**
 * Error response schema
 */
export const AnalysisErrorSchema = z.object({
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
  }),
});

export type AnalysisError = z.infer<typeof AnalysisErrorSchema>;
